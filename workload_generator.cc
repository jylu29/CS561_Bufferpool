#include <sstream>
#include <iostream>
#include <sys/time.h>
#include <unistd.h>
#include <fstream>
#include <string>
#include <cstring>

#include "workload_generator.h"
#include "parameter.h"
using namespace std;


const char value_alphanum[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

std::string get_random_entry(const int entry_size) {
    char *s = new char[(int)entry_size];
    for (int i = 0; i < entry_size; ++i) { // Range of numbers generated by rand is from 0 to 32767
        s[i] = value_alphanum[rand() % (sizeof(value_alphanum) - 1)]; //sizeof(value_alphanum) = 53 because it contains the null character '\0'
    }
    s[entry_size] = '\0';
    return s;
}

void fill_raw_data(long num_pages, int entry_size) {
  ofstream raw_data_file("rawdata_database.dat", std::ofstream::binary);
  int entries_per_page = PAGE_SIZE/entry_size; 
  // Since 'entries_per_page' is an integer, there may be some remaining bytes in the  page 'buffer'.
  // Those remaining bytes will be filled with 0's since we initially initialize all the 'PAGE_SIZE' bytes of the page 'buffer' with 0's through the command memset(buffer, 0, PAGE_SIZE);
  char buffer[PAGE_SIZE];
  string tmp_entry;
  //srand(time(0));
  for(long i = 0; i < num_pages; i++) {
    memset(buffer, 0, PAGE_SIZE); // All the 'PAGE_SIZE' bytes are set to 0 in the character array 'buffer'
    for(int j = 0; j < entries_per_page; j++) {
      tmp_entry = get_random_entry(entry_size);
      strcpy(buffer+j*entry_size, tmp_entry.c_str());
      tmp_entry.clear();
    }
    raw_data_file.write((char*)&buffer[0], PAGE_SIZE);
  }
  raw_data_file.flush(); // Ensures all data is written to the file
  raw_data_file.close(); // Closes the file
}

int WorkloadGenerator::generateWorkload() {
  
  // This method generates the workload
  // However, this considers pinning is disabled.
  // If you want to enforce pin/unpin, you might need to modify this file

  ofstream workload_file;
  workload_file.open("workload.txt");
  Simulation_Environment* _env = Simulation_Environment::getInstance();

  if (_env->simulation_on_disk) { // if the 'simulation_on_disk' is on, we populate the 'rawdata_database.data' with data
    // With this mode on, fill the database file "rawdata_database.dat" with specified number of pages using fixed-length entries
    fill_raw_data(_env->disk_size_in_pages, _env->entry_size);
  }

  int pageId;
  int endPageId = _env->disk_size_in_pages*(_env->skewed_data_perct/100); //endPageId is the total number of skewed pages.
  int entries_per_page = PAGE_SIZE/_env->entry_size;                      // Let's assume total number of pages in disk = 150 and total number of skewed pages = 30
  int offset; // the ordinal number of a entry, also known as the offset
  string tmp_new_entry;
  //cout << "Printing Workload..." << endl;
    std::srand(1);
  for (long i = 0; i < _env->num_operations; i++) { // _env->num_operations is the total number of operations in the workload.txt file
    //srand(time(0));

    int typeDecider = rand() % 100; // Why isn't it 101? 
    int skewed = rand() % 100; // Why isn't it 101?

    if (skewed < _env->skewed_perct)
    {
      pageId = rand() % endPageId; // Suppose total pages in disk = 150 and total number of skewed pages are 30 and if this particular pageId is a skewed pageId, then the pageId ranges from 0 to 29.
    }                              
    else
    {
      pageId = rand() % (_env->disk_size_in_pages - endPageId) + endPageId; // (rand() % (_env->disk_size_in_pages - endPageId)) would be a value from 0 to 119 as we have assumed total skewed pages = 30 and total unskewed pages = 120. So this pageId ranges from 30 to 149.
    } 

    offset = rand() % entries_per_page; // Suppose there are n entries per page, offset ranges from 0 to n-1.


    if(typeDecider < _env->perct_reads)
    {
      workload_file << "R " << pageId << " " << offset << std::endl; // Different operations may contain the same pageId.
    }
    else 
    {
      tmp_new_entry = get_random_entry(_env->entry_size);
      workload_file << "W " << pageId << " " << offset << " " <<
	      tmp_new_entry << std::endl;
      tmp_new_entry.clear();
    }
  }
  
  workload_file.close();

  return 1;
}
